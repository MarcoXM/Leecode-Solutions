# 127. Word Ladder

{% tabs %}
{% tab title="Go" %}
```go
type queue struct {
    word string
    length int
}

func ladderLength(beginWord string, endWord string, wordList []string) int {    
    var q []queue
    var words = make(map[string]struct{})
    var visited = make(map[string]struct{})
    for _, v := range wordList{
        words[v] = struct{}{}
    }
    if _, v := words[endWord]; !v {
        return 0
    }
    q = append(q,queue{beginWord,1})
    visited[beginWord] = struct{}{}
    for len(q)>0 {
        node := q[0]
        q = q[1:]
        if node.word == endWord{
            return node.length
        }
        for i:=0 ;i < len(node.word);i++{
            for j:= 'a'; j <= 'z'; j++ {
                //fmt.Println(j)
                w := node.word[:i] + string(j) + node.word[i+1:]
                _,vi := visited[w]
                if _,v := words[w]; v && w!=node.word && !vi{
                    q = append(q,queue{w,node.length + 1})
                    visited[w] = struct{}{}
                }
            }
        }
    }
    return 0
    
    
}   
```
{% endtab %}

{% tab title="Python" %}
```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in wordList:
            return 0 
        from collections import deque
        import string
        dirs = string.ascii_lowercase
        q = deque()
        ans = 0
        wordList = set(wordList)
        q.append((beginWord,1)) #
        while q:
            node,l = q.popleft()
            if node == endWord:
                return l
            for i in range(len(node)):
                for d in dirs: # 方向有26个
                    w = node[:i] + d + node[i+1:]
                    if w in wordList and w!=node:
                        wordList.remove(w)
                        q.append((w,l+1))    
        return 0
        
```
{% endtab %}

{% tab title="Python" %}
```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        
        
        wl = set(wordList)
        q = collections.deque()
        q.append((1, beginWord))
        used = set()
        if endWord not in wl: return 0
        
        while q:
            ls = len(q)
            ans , node = q.popleft()
            
            if node == endWord:
                return ans 
            
            for idx in range(len(node)):
                for i in range(ord("a"),ord("z") + 1):
                    if node[idx] != chr(i):
                        new_word = node[:idx] + chr(i) + node[idx + 1:]
                        if new_word not in wl or new_word in used: continue
                        # print(new_word,ans)
                        q.append((ans + 1, new_word))
                        used.add(new_word)
                                 
        return 0
            
        
        
        
        
```
{% endtab %}
{% endtabs %}

